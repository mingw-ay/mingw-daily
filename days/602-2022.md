#### 2022/06/02

1. ##### 零钱兑换

   输入一个整数数组`coins`，表示不同面额的硬币。同时没有重复币值，每一种面额的硬币有无限个，同时输入一个整数`amount`表示要凑出的总金额。

   输出可以凑出总金额的组合数

* 完全背包

  每种面额的硬币可以重复选取，如果`coins`数组有重复的当前要先去重

  总之要求的是组合数而非所有组合可能性，就可以使用动态规划来分割为子问题。注意可以重复选取的话依赖的是当前行的子问题。

  ```js
  /**
   * @param {number} amount
   * @param {number[]} coins
   * @return {number}
   */
  var change = function (amount, coins) {
      /* 完全背包，可以重复选取同一面额的硬币 */
      const len = coins.length;
      /* 一维数组表示每个整数的凑成组合数 */
      const np = new Array(amount + 1).fill(0);
      /* 凑0块钱当然是一种方法 */
      np[0] = 1;
  
      for (let i = 0; i < len; i++) {
          for (let j = coins[i]; j <= amount; j++) {
              /* 选择加上当前硬币或者不加 */
              np[j] += np[j - coins[i]];
          }
      }
  
      return np[amount];
  };
  ```

  关于遍历顺序，这里求的是组合数，故而需要按照顺序来决定每种面额选择几个。不能回头。所以先遍历的是`coins`数组，即面额。

  而如果要求排列数，即选择顺序不同也算是不同的选择。则可以通过一列一列地填充，因为方法数是叠加的，并且一列一列地填最终得到了当前面额最终地排列数，之后每次依赖的也是前面的排列数。

  而如果是背包问题的话，由于最终求的是最大的价值，故而与遍历的顺序无关，

  如果一列一列地填充，每一个格子的填充依赖的都是左下角。就是所有的物品都已经选了一遍之后。

  如果一行一行填充，就完全是依赖左上角。

  当然如果是使用二维的`np`数组，就没有这个忧虑了，自己来决定依赖的到底是左上角还是左下角。

