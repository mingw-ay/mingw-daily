#### 2022/05/25

1. ##### 不同的二叉搜索树

   输入一个整数`n`，输出恰好由`n`个值从`1`到`n`或不相同的二叉搜索树的种树。

* 关键是要注意观察例子中的图，由于二叉搜索数的独特性质，其根节点的左边一定都是比他值小的数，右边都是比它值大的数。故而可能将根节点的各种情况列出来，将其分为左子树和右子树两个子问题。然后相乘即某个值作为根节点的可能种树。以`n=4`为例，其节点分布有以下情况，可知可以循环以下某一边的节点个数得到所有情况即可，范围是0~1。`np`数组的定义即`n`个节点能组成二叉搜索树的个数。注意将`np[0]`初始化为1，方便计算。

  | 左树节点个数 | 根节点 | 右树节点个数 |
  | ------------ | ------ | ------------ |
  | 0            | 1      | 3            |
  | 1            | 1      | 2            |
  | 2            | 1      | 1            |
  | 3            | 1      | 0            |

  ```js
  /**
   * @param {number} n
   * @return {number}
   */
  var numTrees = function (n) {
      /* 将一个二叉搜索树分为头部分，左树部分，右树部分 */
      /* 二叉搜索树的可能个数由左树的可能个数×右树的可能个数组成 */
  
      /* 初始化0个，1个，2个结点的可能个数,将0个的情况初始化为一，相当于某一边没有节点 */
      const np = [1, 1, 2];
  
      for (let i = 3; i <= n; i++) {
          /* 由于中间节点占了1个，所以左树的可能节点数为0~i-1 */
          np[i] = 0;
          for (let j = 0; j < i; j++) {
              /* 可能的数量为左右可能情况之积 */
              np[i] += np[j] * np[i - 1 - j];
          }
      }
  
      return np[n];
  };
  ```

  