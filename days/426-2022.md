#### 2022/04/26

1. 求包含所有班级人员的最小区间长度

   输入一个队伍`queue`，包含了一个**绕圈围住**的所有班级人员，同时给定班级数目`classNum`, 输出要包含所有班级人员最小的连续区间的长度

* 这是一个滑窗的问题，需要记录当前区间中每个班级的人数，首先`fast`指针右移直到包含了所有班级的人，然后`slow`指针左移，到了不包含所有班级人员的边界时，记录当前区间长度

  需要注意的时这个队伍是围住的，故而`fast`指针应该能够绕队伍两圈，得到最小的区间

  技巧就是**将这个队伍加长一倍**

  ```js
  const queue = [1, 2, 2, 2, 3, 3, 3, 4]; /* 队伍数据 */
  const classNum = 4; /* 四个班 */
  let len = queue.length;
  
  /* 得到最短区间的方法 */
  const getMinLength = function (queue, classNum, len) {
      queue.push(...queue);
      len += len;
      let minLength = Infinity; /* 初始化最小长度 */
  
      /* 双指针遍历队伍数据 */
      let slow = 0,
          fast = 0;
      /* 使用一个HashMap记录当前区间中每个班级的人数 */
      let studentMap = {};
      /* 记录当前区间中的班级个数 */
      let classNumIn = 0;
      while (fast < len) {
          /* 快指针右移，直到每个班的人员都有了 */
          while (fast < len && classNumIn < classNum) {
              /* 当前人员所在班级编号，转为string */
              let cur = queue[fast].valueOf();
              /* 如果还没有这个班的人或者为0 */
              if (!studentMap[cur]) {
                  studentMap[cur] = (studentMap[cur] || 0) + 1;
                  classNumIn++;
              } else {
                  studentMap[cur]++;
              }
              fast++;
          }
  
          /* slow指针右移，直到已经不包括每个班级的人员了 */
          while (slow <= fast && classNumIn == classNum) {
              let cur = queue[slow].valueOf();
              if (studentMap[cur] > 1) {
                  /* 如果当前这个的人员大于1，之间剪掉 */
              } else if (studentMap[cur] === 1) {
                  /* 如果只剩下一个了 */
                  /* 更新最小区间 */
                  let curLen = fast - slow;
                  if (minLength > curLen) {
                      minLength = curLen;
                  }
                  classNumIn--; /* 包含的班级数减一 */
              }
              studentMap[cur]--;
              slow++;
          }
      }
  
      return minLength;
  };
  
  // 时间复杂度： O(n)
  // 空间复杂度： O(n)
  
  console.log(getMinLength(queue, classNum, len));
  ```

* 使用一个大小为`classNum`的数组记录当前区间中的每个班级人员人数，避免了`Hash`表进行Hash函数的计算耗时

  ```js
  const queue = [2, 2, 2, 3, 1, 3, 3, 4]; /* 队伍数据 */
  const classNum = 4; /* 四个班 */
  let len = queue.length;
  
  /* 使用数组来记录区间中每个班级的人员数量 */
  function getMinSectionLength(queue, classNum, len) {
      /* 首先将数组延长一倍 */
      queue = queue.concat(queue);
      len += len;
  
      /* 使用一个数组记录区间中每个班级的人数 */
      const studentMap = new Array(classNum).fill(0);
      let inQueueClassNum = 0; /* 区间中存在的班级数 */
      let minLength = Infinity;
      /* 遍历数组 */
      let slow = 0,
          fast = 0;
      while (fast < len) {
          /* 首先快指针右移，直到包含所有班级人员 */
          while (fast < len && inQueueClassNum < classNum) {
              let classId = queue[fast]; /* 当前人员的班级编号 */
              studentMap[classId - 1] += 1; /* 记录 */
              /* 判断是否多了一个班 */
              if (studentMap[classId - 1] === 1) {
                  inQueueClassNum++;
              }
              fast++;
          }
  
          /* 慢指针左移，直到不再包含所有班级人员 */
          while (inQueueClassNum === classNum) {
              let classId = queue[slow]; /* 当前人员的班级编号 */
              studentMap[classId - 1] -= 1;
              /* 如果没有这个班的人了,更新最小长度 */
              if (studentMap[classId - 1] === 0) {
                  let curLength = fast - slow;
                  if (curLength < minLength) {
                      minLength = curLength;
                  }
                  inQueueClassNum--;
              }
              slow++;
          }
      }
  
      return minLength;
  }
  
  console.log(getMinSectionLength(queue, classNum, len));
  ```

2. ##### 长度最小的子数组

   经典滑窗问题，复习一下。输入一个含有`n`个正整数的数组以及一个正整数`target`，返回在数组中满足和`≥target`的长度最小的区间的长度。如果没有就返回`0`；

* 快慢指针滑窗，优先`fast`右移，然后`slow`右移。如果遇到了fast已经超出边界，但是没有满足条件注意要直接`break`，否则会进行错误的最小区间长度更新

  ```js
  /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
  var minSubArrayLen = function (target, nums) {
      let sum = 0;/* 记录当前区间的和 */
      /* 快慢指针遍历，进行滑窗 */
      let slow = 0, fast = 0;
      const len = nums.length;
      let minLength = Infinity;
  
      while (fast < len) {
          /* 首先快指针移动，直到sum要大于target了为止 */
          while (sum < target && fast < len) {
              let cur = nums[fast];
              sum += cur;
              fast++;
          }
  
          /* 如果当前len已经等于fast了然而sum小于target */
          if (fast === len && sum < target) {
              break;
          }
  
          /* 慢指针右移，直到sum要小于target了为止 */
          while (sum >= target) {
              let cur = nums[slow];
              sum -= cur;
              slow++;
          }
  
          /* 更新最小区间 */
          let curLength = fast - slow + 1;
          if (curLength < minLength) {
              minLength = curLength;
          }
      }
      return minLength < Infinity ? minLength : 0;
  };
  ```

  