#### 2022/04/26

1. 求包含所有班级人员的最小区间长度

   输入一个队伍`queue`，包含了一个**绕圈围住**的所有班级人员，同时给定班级数目`classNum`, 输出要包含所有班级人员最小的连续区间的长度

* 这是一个滑窗的问题，需要记录当前区间中每个班级的人数，首先`fast`指针右移直到包含了所有班级的人，然后`slow`指针左移，到了不包含所有班级人员的边界时，记录当前区间长度

  需要注意的时这个队伍是围住的，故而`fast`指针应该能够绕队伍两圈，得到最小的区间

  技巧就是**将这个队伍加长一倍**

  ```js
  const queue = [1, 2, 2, 2, 3, 3, 3, 4]; /* 队伍数据 */
  const classNum = 4; /* 四个班 */
  let len = queue.length;
  
  /* 得到最短区间的方法 */
  const getMinLength = function (queue, classNum, len) {
      queue.push(...queue);
      len += len;
      let minLength = Infinity; /* 初始化最小长度 */
  
      /* 双指针遍历队伍数据 */
      let slow = 0,
          fast = 0;
      /* 使用一个HashMap记录当前区间中每个班级的人数 */
      let studentMap = {};
      /* 记录当前区间中的班级个数 */
      let classNumIn = 0;
      while (fast < len) {
          /* 快指针右移，直到每个班的人员都有了 */
          while (fast < len && classNumIn < classNum) {
              /* 当前人员所在班级编号，转为string */
              let cur = queue[fast].valueOf();
              /* 如果还没有这个班的人或者为0 */
              if (!studentMap[cur]) {
                  studentMap[cur] = (studentMap[cur] || 0) + 1;
                  classNumIn++;
              } else {
                  studentMap[cur]++;
              }
              fast++;
          }
  
          /* slow指针右移，直到已经不包括每个班级的人员了 */
          while (slow <= fast && classNumIn == classNum) {
              let cur = queue[slow].valueOf();
              if (studentMap[cur] > 1) {
                  /* 如果当前这个的人员大于1，之间剪掉 */
              } else if (studentMap[cur] === 1) {
                  /* 如果只剩下一个了 */
                  /* 更新最小区间 */
                  let curLen = fast - slow;
                  if (minLength > curLen) {
                      minLength = curLen;
                  }
                  classNumIn--; /* 包含的班级数减一 */
              }
              studentMap[cur]--;
              slow++;
          }
      }
  
      return minLength;
  };
  
  // 时间复杂度： O(n)
  // 空间复杂度： O(n)
  
  console.log(getMinLength(queue, classNum, len));
  ```

* 使用一个大小为`classNum`的数组记录当前区间中的每个班级人员人数，避免了`Hash`表进行Hash函数的计算耗时

  ```js
  const queue = [2, 2, 2, 3, 1, 3, 3, 4]; /* 队伍数据 */
  const classNum = 4; /* 四个班 */
  let len = queue.length;
  
  /* 使用数组来记录区间中每个班级的人员数量 */
  function getMinSectionLength(queue, classNum, len) {
      /* 首先将数组延长一倍 */
      queue = queue.concat(queue);
      len += len;
  
      /* 使用一个数组记录区间中每个班级的人数 */
      const studentMap = new Array(classNum).fill(0);
      let inQueueClassNum = 0; /* 区间中存在的班级数 */
      let minLength = Infinity;
      /* 遍历数组 */
      let slow = 0,
          fast = 0;
      while (fast < len) {
          /* 首先快指针右移，直到包含所有班级人员 */
          while (fast < len && inQueueClassNum < classNum) {
              let classId = queue[fast]; /* 当前人员的班级编号 */
              studentMap[classId - 1] += 1; /* 记录 */
              /* 判断是否多了一个班 */
              if (studentMap[classId - 1] === 1) {
                  inQueueClassNum++;
              }
              fast++;
          }
  
          /* 慢指针右移，直到不再包含所有班级人员 */
          while (inQueueClassNum === classNum) {
              let classId = queue[slow]; /* 当前人员的班级编号 */
              studentMap[classId - 1] -= 1;
              /* 如果没有这个班的人了,更新最小长度 */
              if (studentMap[classId - 1] === 0) {
                  let curLength = fast - slow;
                  if (curLength < minLength) {
                      minLength = curLength;
                  }
                  inQueueClassNum--;
              }
              slow++;
          }
      }
  
      return minLength;
  }
  
  console.log(getMinSectionLength(queue, classNum, len));
  ```

2. ##### 长度最小的子数组

   经典滑窗问题，复习一下。输入一个含有`n`个正整数的数组以及一个正整数`target`，返回在数组中满足和`≥target`的长度最小的区间的长度。如果没有就返回`0`；

* 快慢指针滑窗，优先`fast`右移，然后`slow`右移。如果遇到了fast已经超出边界，但是没有满足条件注意要直接`break`，否则会进行错误的最小区间长度更新

  ```js
  /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
  var minSubArrayLen = function (target, nums) {
      let sum = 0;/* 记录当前区间的和 */
      /* 快慢指针遍历，进行滑窗 */
      let slow = 0, fast = 0;
      const len = nums.length;
      let minLength = Infinity;
  
      while (fast < len) {
          /* 首先快指针移动，直到sum要大于target了为止 */
          while (sum < target && fast < len) {
              let cur = nums[fast];
              sum += cur;
              fast++;
          }
  
          /* 如果当前len已经等于fast了然而sum小于target */
          if (fast === len && sum < target) {
              break;
          }
  
          /* 慢指针右移，直到sum要小于target了为止 */
          while (sum >= target) {
              let cur = nums[slow];
              sum -= cur;
              slow++;
          }
  
          /* 更新最小区间 */
          let curLength = fast - slow + 1;
          if (curLength < minLength) {
              minLength = curLength;
          }
      }
      return minLength < Infinity ? minLength : 0;
  };
  ```

* 不用while里面嵌套两个`While`，可以把`fast`指针右移作为外层循环，然后内层用一个`while`来控制`slow`右移缩小窗口以及更新`minLength`;

  ```js
  /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
  var minSubArrayLen = function (target, nums) {
      let sum = 0;/* 记录当前区间的和 */
      /* 快慢指针遍历，进行滑窗 */
      let slow = 0, fast = 0;
      const len = nums.length;
      let minLength = Infinity;
  
      /* 外层进行快指针遍历 */
      for (; fast < len; fast++) {
          let cur = nums[fast];
          sum += cur;
  
          /* 如果窗口已满足条件，慢指针右移缩小窗口 */
          while (sum >= target) {
              let curLength = fast - slow + 1;
              minLength = Math.min(curLength, minLength);
              sum -= nums[slow];
              slow++;
          }
      }
  
      return minLength < Infinity ? minLength : 0;
  };
  ```

* `O(nlogn)`的算法，使用一个数组记录每一个位置的前缀和，包括并不存在的位置`len`。长度为`len+1`，然后通过二分法，找出每个右边界对应的最大的左边界。

  ```js
  /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
  var minSubArrayLen = function (target, nums) {
      /* 使用一个长度为nums.length + 1的数组记录nums数组每个位置的前缀和 */
      /* 每个位置的前缀和是指不包括自身的前面所有数字的和 */
      /* 由于所有数字都是正数，故而前缀和数组一定是递增的 */
      const sums = [0];
      const len = nums.length;
      let curSum = 0;
      for (let i = 0; i < len; i++) {
          curSum += nums[i];
          sums[sums.length] = curSum;/* 加入当前前缀和 */
      }
      let minLength = Infinity;
  
      /* 右边界索引从1到len，通过二分查找左边界 */
      for (let right = 1; right <= len; right++) {
          let rightSum = sums[right];
          let leftSum = rightSum - target;
          let left;/* 初始化左边界 */
          /* 左边界的前缀和必须要<=rightSum - target */
          /* 开始在0和right之间进行二分查找 */
          let l = 0, r = right;
          while (l <= r) {
              let mid = l + Math.floor((r - l) / 2);
              let midValue = sums[mid];
              /* 如果中点的值比目的值大，往左找 */
              if (midValue > leftSum) {
                  r = mid - 1;
              } else if (midValue === leftSum) {
                  left = mid;
                  break;
              } else {
                  l = mid + 1;
              }
          }
          if (left === undefined) {
              left = r;/* left所在的前缀和肯定是要比leftSum要小的 */
          }
          /* 如果left不为负，更新最小区间长度 */
          if (left >= 0) {
              let curLength = right - left;
              minLength = Math.min(curLength, minLength);
          }
      }
      return minLength < Infinity ? minLength : 0;
  };
  ```

* 一般还是先给定左边界，求满足条件的右边界

  ```js
  /**
   * @param {number} target
   * @param {number[]} nums
   * @return {number}
   */
  var minSubArrayLen = function (target, nums) {
      /* 使用一个长度为nums.length + 1的数组记录nums数组每个位置的前缀和 */
      /* 每个位置的前缀和是指不包括自身的前面所有数字的和 */
      /* 由于所有数字都是正数，故而前缀和数组一定是递增的 */
      const sums = [0];
      const len = nums.length;
      let curSum = 0;
      for (let i = 0; i < len; i++) {
          curSum += nums[i];
          sums[sums.length] = curSum;/* 加入当前前缀和 */
      }
      let minLength = Infinity;
  
      /* 通过二分法给定左右边界求出大于等于target的最小边界 */
      function getBound(left, right, target, arr) {
          /* 边界为[left,right] */
          while (left <= right) {
              let mid = (left + right) >> 1;/* 得到中点 */
              let midValue = arr[mid];
              /* 如果midValue太小了，往右找 */
              if (midValue < target) {
                  left = mid + 1;
              } else if (midValue === target) {
                  return mid;
              } else {
                  right = mid - 1;
              }
          }
          return arr[left] >= target ? left : -1;/* left总是指向大于target的值 */
      }
  
  
      /* 遍历sums作为左边界 */
      for (let i = 0; i <= len; i++) {
          let leftSum = sums[i];
          let targetSum = leftSum + target;
  
          /* 找到大于等于targetSum的最小边界 */
          let bound = getBound(i, len, targetSum, sums);
          if (bound > 0) {
              let curLength = bound - i;
              minLength = Math.min(curLength, minLength);
          }
      }
      return minLength < Infinity ? minLength : 0;
  };
  ```

  