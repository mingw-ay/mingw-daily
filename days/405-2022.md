#### 2022/04/05

1. ##### 完全二叉树的节点个数

   输入为一个完全二叉数的根节点`root`，返回节点个数

   注意完全二叉树的定义：除了最底层节点可能没填满，其余都是满的。如当最底层为第`h`层，则该层包含$1~到~2^h$个节点，如下图，最底层为第`2`层：

   ![img](405-2022_imgs/complete.jpg)

* 层序遍历，时间复杂度为O(n)

  ```js
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var countNodes = function (root) {
      if (!root) return 0;
      /* 层序遍历，时间复杂度为O(n) */
      const nodesQueue = [root];
      let nodesNum = 0;
  
      while (nodesQueue.length) {
          let size = nodesQueue.length;
          nodesNum += size;
  
          while (size--) {
              let cur = nodesQueue.shift();
              if (cur.left) nodesQueue.push(cur.left);
              if (cur.right) nodesQueue.push(cur.right);
          }
      }
      return nodesNum;
  };
  ```


* 后序遍历，从下往上数

  ```js
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var countNodes = function (root) {
      /* 递归，后序遍历，从后往前数 */
      if (!root) return 0;/* 边界条件 */
  
      /* 递归调用,先得到左右子树的数量，然后加上当前值 */
      return countNodes(root.left) + countNodes(root.right) + 1;
  };
  ```

* 前序遍历也行，没有后续简洁，但更好理解

  ```js
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var countNodes = function (root) {
      /* 递归，前序遍历，维护一个全局变量num */
      this.nodesNum = 0;
      if (root) getNodesNum(root);
      return nodesNum;
  
      function getNodesNum(node) {
          this.nodesNum++;
  
          if (node.left) getNodesNum(node.left);
          if (node.right) getNodesNum(node.right);
      }
  };
  ```

* 递归

  利用完全二叉树的特性，通过找到子树中的所有满二叉树然后通过公式求得总结点个数

  ```js
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var countNodes = function (root) {
      if (!root) return 0;
      let level = 1;
      let left = root.left, right = root.right;
  
      /* 得到左右深度 */
      while (left && right) {
          level++;
          left = left.left;
          right = right.right;
      }
      /* 判断是不是满二叉树 */
      if (left) {
          /* 此时right已经指向空，但是left还是指向非空节点，说明非满,只能递归左右子树 */
          return 1 + countNodes(root.left) + countNodes(root.right);
      } else {
          return 2 ** level - 1;/* 满二叉树的节点个数为2^层数-1 */
      }
  };
  ```

2. ##### 平衡二叉树

   输入一个二叉树的根结点`root`, 判断是不是**`高度`**平衡的二叉树。

   所谓高度平衡就是，**每个**节点的左右子树高度差的绝对值都不超过一。

* 递归法

  所以应该采用后序遍历，从下往上数才是高度。并且在遍历的过程中是要分别得到每个节点的左右子树的最大高度的，刚好进行比较，只需维护一个`Boolean`值即可

  ```js
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isBalanced = function (root) {
      if (!root) return true;
      this.flag = true;/* 记录是否平衡二叉树 */
      getHeight(root);
      return this.flag;
      function getHeight(node) {
          /* 后序遍历，从下开始计算每个左右子树的深度 */
          if (!node) return 0;
  
          let leftHeight = getHeight(node.left);
          let rightHeight = getHeight(node.right);
          if (Math.abs(leftHeight - rightHeight) > 1) this.flag = false;
          return Math.max(leftHeight, rightHeight) + 1;
      }
  };
  ```

  优化一下，返回-1表示不是平衡二叉树

  ```js
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isBalanced = function (root) {
      if (!root) return true;
      return getHeight(root) != -1;
      function getHeight(node) {
          /* 后序遍历，从下开始计算每个左右子树的深度 */
          if (!node) return 0;
  
          let leftHeight = getHeight(node.left);
          let rightHeight = getHeight(node.right);
          if (leftHeight == -1 || rightHeight == -1) return -1;/* 如果遇到了-1 */
          return Math.abs(leftHeight - rightHeight) > 1 ? -1 : Math.max(leftHeight, rightHeight) + 1;
      }
  };
  ```

  ​         如上后序遍历自下而上数出来才是真正的高度，不论是层序遍历还是`DFS`中的前序遍历都是从上往下数。数出来的是深度。从下网上数的过程中就可以判断每个节点的左右子树的高度差，从某种意义上来说，这才是时间复杂度为`O(n)`的算法。而如果要从上往下数深度，就要首先从上往下找到每个节点的左右子树进行对比。需要调用求深度的函数。

  ​       然而后序遍历的方法很难转化成采用堆栈的迭代法。

*  迭代法

    以下首先将原来的前序遍历的函数转为迭代法，通过堆栈，原来前序遍历的递归法求最大深度其实是一种相当标准的回溯方法，采用堆栈也是模拟这个回溯的过程，再走过的每个节点都先`push`一个`null`作为标志，之后再回溯就让深度减一。然后每次循环都与最大深度进行比较。进而得到最大深度。

  以下是通过前序遍历递归法求最大深度的代码：

  ```js
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var maxDepth = function (root) {
      if(!root) return 0;
      this.maxDepth = 0;
      getDepth(root, 1);
      return this.maxDepth;
  
      function getDepth(node, level) {
          /* 判断需不需要更新最大深度 */
          this.maxDepth = this.maxDepth < level ? level : this.maxDepth;
  
          /* 递归调用 */
          if (node.left) getDepth(node.left, level + 1);
          if (node.right) getDepth(node.right, level + 1);
      }
  };
  ```

  很显然，这是一个从上往下求深度的过程。将其转为迭代法，然后再前序遍历每个节点的左右子树是否合规。

  ```js
  /* 使用堆栈模拟前序遍历求深度，求最大深度相当于找最长的路径，是一个回溯的过程 */
  function getDepth(node) {
      if (!node) return 0;
      let maxDepth = 0;/* 记录最大深度 */
      let level = 0;/* 表示当前节点所在深度 */
      const nodeStack = [node];
  
      while (nodeStack.length) {
          let cur = nodeStack.pop();
          /* 如果cur不为空，以中右左的顺序来push进堆栈，模拟后序遍历 */
          if (cur) {
              level++;/* 表示所在层数加一 */
              /* 中间节点push一个null进来，标识之后再遇到就是回溯了 */
              nodeStack.push(null);
              /* 然后再将右树左树push进来 */
              if (cur.left) nodeStack.push(cur.left);
              if (cur.right) nodeStack.push(cur.right);
          } else {
              level--;/* 回溯，回到上一层 */
          }
          /* 判断是不是比当前最大深度要大 */
          maxDepth = maxDepth < level ? level : maxDepth;
      }
  
      return maxDepth;
  }
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isBalanced = function (root) {
      if (!root) return true;
      /* 通过堆栈模拟前序遍历 */
      const nodeStack = [[root.left, root.right]];
  
      /* 遍历，开始从上到下对比每组左右树的高度差 */
      while (nodeStack.length) {
          let cur = nodeStack.pop();
          let leftNode = cur[0];
          let rightNode = cur[1];
          let leftHeight = getDepth(leftNode);
          let rightHeight = getDepth(rightNode);
  
          if (Math.abs(leftHeight - rightHeight) > 1) return false;
  
          /* 先push右树的孩子再push左树的孩子 */
          if (rightHeight > 2) nodeStack.push([rightNode.left, rightNode.right]);
          if (leftHeight > 2) nodeStack.push([leftNode.left, leftNode.right]);
      }
      return true;
  };
  ```

  * 要减少重排重绘，首先要了解哪些动作会导致它的发生。经过上面的讨论，明显减少重排是性能优化非常重要的一环。
  
  * 以下动作会导致重排：
  
    - 添加/删除可见的`DOM`元素
  
    - 改变元素位置
  
    - 改变元素尺寸：通过更改`margin`、`padding`、`border`、`width`、`height`等属性
  
    - 改变元素内容
  
    - 改变元素字体大小
  
    - 改变浏览器窗口尺寸，用户手动更改或者发生`resize`时间等
  
    - 激活了`CSS`伪类，然后里面有些涉及尺寸的属性
  
    - 增添伪元素当然也算
  
    - 设置`style`属性的值，如果通过`style`改变节点样式，每设置一次都会触发一次回流
  
    - 读取元素某些属性或者调用某些计算方法，如`offsetWidth`，`offsetHeight`等，方法包括`getComputedStyle`或者`IE`浏览器中的`currentStyle`。
  
      为什么读取一个元素也会触发重排呢，因为浏览器的`渲染队列机制`，每次修改DOM样式的代码并不会立即执行，而在读取属性的时候，为了保证`即时性`和`准确性`会立即触发重排。而这也正是之后建议`读写分离`的原因
  
  * 同时重排影响的范围
  
    由于浏览器渲染界面是基于流式布局模型的，所以某个元素的样式更改可能会导致周围`DOM`也得重新排列。影响的范围有两种
  
    * 全局，从根节点`body`开始整个渲染树的布局都得重新计算
    * 局部，只需要对渲染树的某个部分进行重新布局
  
  * 很显然，全局范围的重排是由于元素之间的嵌套，而所有元素都是在`body`标签中的
  
  * 而局部布局则是将一个DOM节点的宽高以及位置之类的属性写死了，脱离的整体文件流，故而对该`DOM元素`或者其内部元素的更改指挥在其内部触发重排
  
  * 而重绘：则是所有对元素的视觉表现属性如颜色`visibility`等的修改，就会导致`重绘`。
  
    
  
  4. 减少重排的办法
  
     > 重排的代价昂贵，影响页面性能，在严重时会让UI展示变得非常缓慢，阻塞用户的交互行为。而要减少重排的负面影响主要可以从两方面下手：减少重排的次数，减少从拍的范围
  
  * 减少重排范围
  
    * 使用`absolute`，`fixed`等让`DOM元素`脱离文档流，不会对其他节点造成太多影响，同时当要增加一个绝对定位的元素时，其他节点的像素绘制可能会有变化，但是不会导致重排
  
    * 对于某些宽高不定的元素最好提前设置其所在块级元素的宽高，尤其时图片，在渲染前必须指定其大小，因为第一次排列实在图片加载之前发生的，如果不设置宽高，加载出来图片后很可能导致整个页面重排
  
    * 尽量不适用`table`进行布局，因为对table的任何一个小部分的改动都会造成整个`table`的重新布局。同时如果需要隐藏某行某列可以设置`visibility:collapse`, 这个值可以从表中快速删除行或者列，而不强制重新计算整个表的宽度或者高度。
  
      如果不得已使用`table`的话，可以通过设置`table-layout:auto;`或者`table-layout：fixed;`来让`table`一行一行的渲染，限制重排的影响范围。同时设置`fixed`属性后可以通过指定width来限制表格的宽度，而`text-overflow`属性用于文字过长时显示省略号。
  
  * 减少重排的次数
  
    * css属性读写分离
  
      通过上面的讨论直到，如果读和写交叉出现，基本上每次进行读操作都会强制执行前面的写操作导致重新渲染（重排重绘）。如下面例子所示
  
      ```js
      // bad 每次读取会强制刷新，一共触发四次重排重绘
      div.style.top = div.offsetTop + 1 + 'px';
      div.style.right = div.offsetRight + 1 + 'px';
      div.style.bottom = div.offsetBottom + 1 + 'px';
      div.style.left = div.offsetLeft + 1 + 'px';
      
      // 读写分离，好一点，缓存布局信息，只会触发一次重排+重绘。因为只读的时候不会倒是重排
      let curTop = div.offsetTop;
      let curRight = div.offsetRight;
      let curBottom = div.offsetBottom;
      let curLeft = div.offsetLeft;
      
      // 集中写，触发Flush渲染队列，只触发一次渲染
      div.style.top = curTop + 1 + 'px';
      div.style.right = curRight + 1 + 'px';
      div.style.bottom = curBottom + 1 + 'px';
      div.style.left = curLeft + 1 + 'px';
      ```
  
      关于渲染队列机制：
  
      > 在代码从上往下执行的时候，把所有要修改`DOM`样式的代码都放入队列中，然后一次性同一渲染，从而只触发一次回流和重绘。利用该运行机制可以进行读写分离，来控制浏览器的渲染次数
  
    * 集中更改样式
  
      为了避免频繁地操作样式，对于一个静态页面而言，更明智并且可维护地做法是切换或者增加`class`。而倘若要通过`style`属性来批量的操作元素样式地话，更好地方法时通过字符串模板统一在`style.cssText`变量进行编辑，虽然现在大部分现代浏览器都支持`Flush`队列进行渲染队列优化，但是有些老版本地浏览器如`IE6`依然效率低下。如下
  
      ```js
      // 可能不太好
      let top = 10;
      let left = 10;
      el.style.top = top + "px";
      el.style.left = left + "px";
      
      // 批量操作style可以通过cssText
      el.style.cssText += `;left: ${left}; top: ${top};`;
      
      // 比较好的方法是操作classList，
      // Element.classList是一个只读属性
      // 返回一个实时的DOMTokenList集合
      // 标识某个DOM元素的类属性
      // 提供了许多有用的函数
      const div = document.createElement("div");
      div.className = "foo";
      
      console.log(div.outerHTML); // <div class="foo"></div>
      
      let classes = div.classList;
      console.log(classes.contains("foo")); // true
      
      // 使用classList API移出、添加类，可以带多个参数，会自动去重
      div.classList.remove("foo");
      div.classList.add("anotherclass");
      
      // toggle,如果已经存在则移出，否则添加
      div.classList.toggle("visible");
      
      // 添加或者删除，取决于第二个参数，Boolean值，true则add，否则就相当于remove
      let i = 4;
      div.classList.toggle("visible", i < 10); // 强制add，不管有没有，返回true
      ```
  
      