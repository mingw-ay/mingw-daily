#### 2022/06/17

1. ##### 打家劫舍Ⅲ

   输入一棵二叉树`root`，从根节点开始行窃，相连的节点不能打劫，返回能够盗取的最高金额

* 递归，暴力递归，两种可能性

  * 偷当前节点，则跳过左右节点
  * 不偷当前节点

  ```ts
  class TreeNode {
        val: number;
        left: TreeNode | null;
        right: TreeNode | null;
  
        constructor(val: number, left?: TreeNode | null, right?: TreeNode | null) {
              this.val = (val === undefined ? 0 : val);
              this.left = (left === undefined ? null : left);
              this.right = (right === undefined ? null : right);
        }
  }
  
  
  function rob(root: TreeNode | null): number {
        // 暴力解法，判断是否偷窃当前节点，后序遍历得到结果，然后返回两种情况较大者
        if (root === null) {
              return 0;
        }
  
  
        // 如果偷当前节点，则跳过左右节点
        let case1 = root.val;
        if (root.left) {
              case1 += rob(root.left.left) + rob(root.left.right);
        }
        if (root.right) {
              case1 += rob(root.right.left) + rob(root.right.right);
        }
  
        // 不偷当前节点
        let case2 = 0;
        case2 += rob(root.left) + rob(root.right);
  
        return Math.max(case1, case2);
  };
  ```

  由于可能会重复计算，可以使用一个`map`记忆遍历过的节点

  ```ts
  /**
   * Definition for a binary tree node.
   * class TreeNode {
   *     val: number
   *     left: TreeNode | null
   *     right: TreeNode | null
   *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
   *         this.val = (val===undefined ? 0 : val)
   *         this.left = (left===undefined ? null : left)
   *         this.right = (right===undefined ? null : right)
   *     }
   * }
   */
  
  function rob(root: TreeNode | null): number {
      // 一个map存储走过的节点
      const robbedMap: Map<TreeNode, number> = new Map();
  
      return (
          function traversal(root: TreeNode | null): number {
              if (root === null) {
                  return 0;
              }
  
              // 判断是否偷过
              if (robbedMap.has(root)) {
                  return robbedMap.get(root);
              }
  
  
              // 偷当前节点
              let case1 = root.val;
              if (root.left) {
                  case1 += traversal(root.left.left) + traversal(root.left.right);
              }
              if (root.right) {
                  case1 += traversal(root.right.left) + traversal(root.right.right);
              }
  
  
              // 不偷当前节点
              let case2 = traversal(root.left) + traversal(root.right);
  
              // 记忆
              let result = Math.max(case1, case2);
              robbedMap.set(root, result);
              
              return result;
          }(root)
      )
  };
  ```

* 动态规划，从下往上遍历，返回偷当前节点与不偷当前节点两种情况。

  注意如果不偷当前节点，那左右子节点就有偷和不偷两种情况

  ```ts
  /**
   * Definition for a binary tree node.
   * class TreeNode {
   *     val: number
   *     left: TreeNode | null
   *     right: TreeNode | null
   *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
   *         this.val = (val===undefined ? 0 : val)
   *         this.left = (left===undefined ? null : left)
   *         this.right = (right===undefined ? null : right)
   *     }
   * }
   */
  
  function rob(root: TreeNode | null): number {
      // 递归，返回两种情况，偷当前节点和不偷当前节点的金额
      function traversal(root: TreeNode | null): number[] {
          // 遇到空节点则均为0
          if (root === null) {
              return [0, 0];
          }
  
          // 得到左节点的两种情况
          const leftResults: number[] = traversal(root.left);
  
          // 右节点
          const rightResults: number[] = traversal(root.right);
  
          // 返回两种情况
          // 偷当前节点
          let case1 = leftResults[1] + rightResults[1] + root.val;
  
          // 不偷当前节点
          let case2 = Math.max(leftResults[0], leftResults[1]) + Math.max(rightResults[0], rightResults[1]);
  
          return [case1, case2];
      }
  
  
      return Math.max(...traversal(root));
  };
  ```

  