#### 2022/04/13

1. ##### 二叉搜索树的最近公共祖先

   输入一个二叉搜索树的根节点`root`，以及两个指定节点`p`，`q`；要返回两个指定节点的最近公共祖先。`p`和`q`一定在给定的树中。

* 由于二叉搜索树的特性，可以直接从上往下按照固定方向找

  如果`p`和`q`的值在`root`的值的两边，那就说明`root`本身是最近公共祖节点

  而如果率先找到了`p`或者`q`，那么当前节点就是最近公共祖节点

* 采用从上往下的前序遍历并且有方向地查找

  ```js
  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
      /* 由于二叉搜索树的左右值大小确定，故而查找方向确定 */
      /* 如果当前就是p或者q，那就是最近公共祖先 */
      if (root == p || root == q) return root;
  
      /* 如果root的值在p，q的中间，那么说明root就是最近公共祖先 */
      if (root.val > p.val && root.val < q.val) return root;
      if (root.val > q.val && root.val < p.val) return root;
  
      /* 如果p和q都在固定一侧 */
      if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
      if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
  };
  ```

* 迭代法，其实用不着递归，反正从某种意义上是按照固定路径去找

  ```js
  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
      let cur = root;
  
      /* 按照固定方向查找 */
      while (cur) {
          /* 如果找到了就直接返回 */
          if (cur.val == p.val || cur.val == q.val)
              return cur;
          /* 如果cur的值在中间 */
          if (cur.val > p.val && cur.val < q.val)
              return cur;
          if (cur.val < p.val && cur.val > q.val)
              return cur;
          /* 否则就根据大小看往那边找 */
          if (cur.val > p.val && cur.val > q.val)
              cur = cur.left;
          else cur = cur.right;
      }
  };
  ```

* 优化一下，首先保证p的值小于q的值，然后再迭代

  ```js
  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
      /* 初始化当前指针 */
      let cur = root;
  
      /* 保证p的值小于q的值 */
      if (p.val > q.val)
          [p, q] = [q, p];
  
      /* 迭代，二叉搜索树搜索时按照固定路径 */
      while (cur) {
          if (cur.val == p.val || cur.val == q.val)
              return cur;
  
          /* 如果cur.val在中间 */
          if (cur.val > p.val && cur.val < q.val) return cur;
  
          /* 如果p，q都小于cur.val, 往左找 */
          if (cur.val > q.val) cur = cur.left;
          /* 反之往右找 */
          else cur = cur.right;
      }
  };
  ```

* 如果明确判定的顺序可以看着更加简洁

  ```js
  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
      /* 保证p的值小于q的值 */
      if (p.val > q.val)
          [p, q] = [q, p];
  
      /* 迭代，首先决定往那边走 */
      while (root) {
          if (root.val < p.val) root = root.right;
          else if (root.val > q.val) root = root.left;
          else return root;
      }
  };
  ```

  