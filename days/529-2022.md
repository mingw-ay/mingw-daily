#### 2022/05/29

1. ##### 最后一块石头的重量

   输入一个整数数组`stones`，表示一堆石头的各自重量。

   可以选择任意两块石头相撞，每次相撞的时候重量会相互抵消，粉碎，比较重的会留下剩下的部分，一样重的话两块石头都完全粉碎，相撞知道最后最多只剩下一块石头，返回该石头的最小重量。如果没有剩下则返回0。

   类似子集问题，就是分为两个子集，然后重量相互抵消，需要让两个子集直接的质量差最小。

   可以用记录`Boolean`值得方式得到这堆石头能得到得所有子集的质量和的可能性，最接近中点的就是答案。

   也可以就作为一个`01背包`，将`stones`数组看作两个维度的数组，同时最大容量为`stones`总质量的一半，得到的最大价值就是最接近总质量一半的子集

   ```js
   /**
    * @param {number[]} stones
    * @return {number}
    */
   var lastStoneWeightII = function (stones) {
       /* 尽量分成重量相同的两堆，首先得到总质量的一半 */
       /* 然后通过动态规划算出不超过一半的最大重量子集 */
       const len = stones.length;
       const total = stones.reduce((prev, cur) => prev + cur, 0);
       /* 得到一半的位置 */
       const maxWeight = total >> 1;
   
       /* 如果只有一块石头 */
       if (len === 1) {
           return stones[0];
       }
   
       /* 一维的np数组 */
       const np = new Array(maxWeight + 1).fill(0);
       /* 初始化第一行 */
       for (let i = stones[0]; i <= maxWeight; i++) {
           np[i] = stones[0];
       }
   
       /* 开始填充 */
       for (let i = 1; i < len; i++) {
           /* 如果已经遇到了恰好等于maxWeight，直接返回 */
           if (np[maxWeight] === maxWeight) {
               return total - (2 * maxWeight);
           }
           /* 逆序来更新每一行 */
           for (let j = maxWeight; j >= stones[i]; j--) {
               np[j] = Math.max(np[j], np[j - stones[i]] + stones[i]);
           }
       }
   
       return total - (2 * np[maxWeight]);
   };
   ```

   确定`dp`数组以及下标的含义

   `dp[j]`表示最大容量为`j`的背包能够装的石头的最大重量。

   没必要初始化第一行，可以直接将`np`数组所有位置初始化为0，同时也不用考虑数组长度是否为1，因为如果只有一块石头是不可能装进容量仅仅是它的一半的背包的

   ```js
   /**
    * @param {number[]} stones
    * @return {number}
    */
   var lastStoneWeightII = function (stones) {
       /* 尽量分成重量相同的两堆，首先得到总质量的一半 */
       /* 然后通过动态规划算出不超过一半的最大重量子集 */
       const len = stones.length;
       const total = stones.reduce((prev, cur) => prev + cur, 0);
       /* 得到一半的位置 */
       const maxWeight = total >> 1;
   
       /* 一维的np数组 */
       const np = new Array(maxWeight + 1).fill(0);
   
       /* 开始填充 */
       for (let i = 0; i < len; i++) {
           /* 逆序来更新每一行 */
           for (let j = maxWeight; j >= stones[i]; j--) {
               np[j] = Math.max(np[j], np[j - stones[i]] + stones[i]);
           }
           /* 如果已经遇到了恰好等于maxWeight，直接返回 */
           if (np[maxWeight] === maxWeight) {
               return total - (2 * maxWeight);
           }
       }
   
       return total - (2 * np[maxWeight]);
   };
   ```

   之前的分割等和子集是要求恰好装满，而这个是要求能装多少装多少。