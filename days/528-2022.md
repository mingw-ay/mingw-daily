#### 2022/05/28

1. ##### 分割等和子集

   输入一个只包含正整数的非空数组`nums`，判断是否可以将这个数组分为两个和相等的子集

* 暴力回溯，首先判断和是不是偶数，然后再暴力回溯找到和为数组总和一般的子集

  ```js
  /**
   * @param {number[]} nums
   * @return {boolean}
   */
  var canPartition = function (nums) {
      /* 求和 */
      const sum = nums.reduce((prev, cur) => prev + cur, 0);
      /* 如果sum不是偶数 */
      if (sum & 1 === 1) {
          return false;
      }
  
      /* 回溯寻找能找到目标和的子集 */
      const len = nums.length;
      function backTracking(startIndex, target) {
          /* 剪枝 */
          if (target < 0) {
              return false;
          }
  
          if (target === 0) {
              return true;
          }
  
          /* 开始选择 */
          for (let i = startIndex; i < len; i++) {
              if (backTracking(i + 1, target - nums[i]) === true) {
                  return true;
              }
          }
  
          return false;
      }
  
      /* 初始化target为sum的一半 */
      return backTracking(0, sum / 2);
  };
  ```

* 动态规划，初始化一个二维的`np`数组。类似于`01背包`，每个数字可能放也可能不放，能不能组成目标和主要就看目标和减去当前数字能不能组或者不考虑当前数字能不能组。对于子集问题，要找到所有可能性才回溯，只要判断有没有没必要回溯，类似记录前面数字中可能组成的目标和

  ```js
  /**
   * @param {number[]} nums
   * @return {boolean}
   */
  var canPartition = function (nums) {
      /* 求和 */
      const sum = nums.reduce((prev, cur) => prev + cur, 0);
      /* 如果sum不是偶数 */
      if (sum & 1 === 1) {
          return false;
      }
  
      /* 动态规划，np数组为二维，行表示可以选择的数字范围，列表示每个目标的子集和 */
      /* 每个空格填充true或者false，第一列表示目标和为0初始化为true，其余位置除了第一行的当然数字位置全都初始化为false */
      const target = sum / 2;
      const len = nums.length;
      const np = new Array(len).fill(0).map(row => new Array(target + 1).fill(false));
  
      /* 初始化第一列 */
      for (let i = 0; i < len; i++) {
          np[i][0] = true;
      }
      /* 初始化第0行 */
      np[0][nums[0]] = true;
  
      /* 开始填充 */
      for (let i = 1; i < len; i++) {
          for (let j = 1; j <= target; j++) {
              /* 不考虑放入当前数字 */
              np[i][j] = np[i - 1][j];
              /* 考虑放入当前数字 */
              if (nums[i] <= j && np[i - 1][j - nums[i]] === true) {
                  np[i][j] = true;
              }
          }
          /* 找到了就可以返回 */
          if (np[i][target] === true) {
              return true;
          }
      }
  
      return false;
  };
  ```

* 使用一个一维数组记录，方便用其一行的结果来覆盖，同时可以进行剪枝

  ```js
  /**
   * @param {number[]} nums
   * @return {boolean}
   */
  var canPartition = function (nums) {
      /* 求和 */
      const sum = nums.reduce((prev, cur) => prev + cur, 0);
      /* 如果sum不是偶数 */
      if (sum & 1 === 1) {
          return false;
      }
  
      /* 使用一个一维数组记录前面的数字可以组成的所有和 */
      const len = nums.length;
      const target = sum / 2;
      const np = new Array(target + 1).fill(false);
      /* 目标和为0以及目标和就是当前第一个数字的位置设为true */
      np[0] = true, np[nums[0]] = true;
  
      /* 从第二个数字开始遍历 */
      for (let i = 1; i < len; i++) {
          /* 从后往前判断，防止重复填 */
          /* 如果数字大于target直接返回false */
          if (nums[i] > target) {
              return false;
          }
          for (let j = target; j >= nums[i]; j--) {
              /* 两种可能加上当前数字或者不加 */
              np[j] = np[j] || np[j - nums[i]];
          }
          if (np[target] === true) {
              return true;
          }
      }
  
      return false;
  };
  ```

  也可以将其完全看作`01背包`，每个数字表示一个物品，其容量`weight`是数字大小，`value`也是数字大小，这样最终装入的最大价值最大就是最大容量这么大，最大容量即`sum/2`，故而如果最终得到的最大价值就等于`sum/2`，表示找到了。

  当然记录`true`或者`false`表示当前可选择的数字是否可能组成这个目标和显得更加直观

* `01背包`版，将`nums`数组等同于`weights`以及`values`数组，最大容量为`sum/2`, 如果恰好找到了即可返回`true`

  ```js
  /**
   * @param {number[]} nums
   * @return {boolean}
   */
  var canPartition = function (nums) {
      /* 求和 */
      const sum = nums.reduce((prev, cur) => prev + cur, 0);
      /* 如果sum不是偶数 */
      if (sum & 1 === 1) {
          return false;
      }
  
      /* 真正的01背包，将每个数字本身作为容量以及价值 */
      const len = nums.length;
      const target = sum / 2;
      const np = new Array(target + 1).fill(0);
  
      /* 首先初始化第一行 */
      for (let i = nums[0]; i < target + 1; i++) {
          np[i] = nums[0];
      }
  
      /* 开始遍历每个数字 */
      for (let i = 1; i < len; i++) {
          /* 如果由数字比target大，可以直接返回false */
          if (target < nums[i]) {
              return false;
          }
          /* 从后往前填，防止重复放入一个数字 */
          for (let j = target; j >= nums[i]; j--) {
              np[j] = Math.max(np[j], np[j - nums[i]] + nums[i]);
          }
          /* 找到了目标子集 */
          if (np[target] === target) {
              return true;
          }
      }
  
      return false;
  };
  ```

  